using System;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using TransformsAI.Unity.WebGL.Interop.Internal;
using TransformsAI.Unity.WebGL.Interop.Types;
using static TransformsAI.Unity.WebGL.Interop.Editor.GeneratorCommon;

namespace TransformsAI.Unity.WebGL.Interop.Editor
{
    public static class TsLibGenerator
    {
        public static StringBuilder Builder
        {
            get => GeneratorCommon.Builder;
            set => GeneratorCommon.Builder = value;
        }

        private const string ReturnValueType = nameof(JsValue);
        private const string JsRuntimeType = "JsRuntime";
        private const string JsRuntimeConstructorType = JsRuntimeType + "Constructor";
        private const string TypeEnumType = nameof(JsTypes);

        public static string GenerateTsLib()
        {
            Builder = new StringBuilder();
            Builder.AppendLine("// This file was automatically generated by TsLibGenerator.cs");

            WriteReturnValueType();
            Builder.AppendLine();

            WriteTypeIdEnum();
            Builder.AppendLine();

            WriteJsRuntime();
            Builder.AppendLine();

            WriteConstructor();
            Builder.AppendLine();

            WriteModule();

            return Builder.ToString();
        }

        private static void WriteModule()
        {
            using (Builder.AppendLine("declare var Module : ").Brace())
            {
                Builder.Append("['").Append(ConstructorModuleKey)
                    .Append("']: ").Append(JsRuntimeConstructorType).AppendLine(";");
            }
        }

        private static void WriteReturnValueType()
        {
            using (Builder.Append("interface ").Append(ReturnValueType).Append(" ").Brace())
            {
                Builder.AppendLine("type: number,");
                Builder.AppendLine("value: number | string,");
            }
        }



        private static void WriteMethod(MethodInfo method)
        {
            var paramList = method.GetParameters();

            var isStandardMethod =
                method.ReturnType != typeof(void) &&
                paramList.Length > 0 && paramList[0].IsOut &&
                paramList[0].ParameterType.GetElementType() == typeof(int);

            if (!isStandardMethod)
                throw new Exception($"Unsupported extern method {method.Name} in {method.DeclaringType}");

            Builder.Append(method.Name).Append(": (").AppendParams(method).AppendLine($") => {ReturnValueType};");
        }


        private static StringBuilder AppendParams(this StringBuilder s, MethodBase method)
        {
            var paramList = method.GetParameters();
            paramList = paramList.Where(it => !it.IsOut).ToArray();
            var length = paramList.Length;
            if (length == 0) return s;

            void AppendParam(ParameterInfo p) => s.Append(p.Name).Append(": ").Append(p.ParameterType.JsType());

            AppendParam(paramList[0]);

            for (var i = 1; i < length; i++)
            {
                s.Append(", ");
                AppendParam(paramList[i]);
            }
            return s;
        }

        private static bool IsSpecialMethod(MethodInfo method) =>
            method.Name == nameof(RuntimeRaw.InitializeInternal);


        private static string JsType(this Type type)
        {
            if (type == typeof(bool)) return "boolean";
            if (type == typeof(string)) return "string";
            if (!type.IsValueType) return "number"; // pointers are references
            if (Marshal.SizeOf(type) <= 8) return "number";
            throw new InvalidCastException("Cannot Marshal type " + type);
        }

        private static void WriteJsRuntime()
        {
            using (Builder.Append("interface ").Append(JsRuntimeType).Append(" ").Brace())
            {
                foreach (var method in RuntimeMethods)
                {
                    if (!IsSpecialMethod(method)) WriteMethod(method);
                }
            }
        }

        private static void WriteTypeIdEnum()
        {

            var values = (JsTypes[])Enum.GetValues(typeof(JsTypes));
            using (Builder.Append("enum ").Append(TypeEnumType).Append(" ").Brace())
            {
                foreach (var t in values)
                    Builder.Append(t).Append(" = ").Append((int)t).AppendLine(",");
            }
        }

        private static void WriteArrayBuilder(string arrayBuilderType)
        {
            var typedArrayType = "TypedArray";
            var arrayTypeCodeType = nameof(TypedArrayTypeCode);

            var values = (TypedArrayTypeCode[])Enum.GetValues(typeof(TypedArrayTypeCode));

            using (Builder.Append("type ").Append(typedArrayType).Append(" =").Indent())
            {
                for (var i = 0; i < values.Length; i++)
                {
                    Builder.Append("| ").Append(values[i]).AppendLine(i == values.Length - 1 ? ";" : "");
                }
            }

            using (Builder.Append("enum ").Append(arrayTypeCodeType).Append(" ").Brace())
            {
                foreach (var t in values)
                    Builder.Append(t).Append(" = ").Append((int)t).AppendLine(",");
            }

            Builder.AppendLine();

            Builder.Append("type ").Append(arrayBuilderType)
                .AppendLine($" = (pointer: number, typeCode: {arrayTypeCodeType}, length: number) => {typedArrayType};");
        }

        private static void WriteConstructor()
        {
            var arrayBuilderType = "ArrayBuilder";
            var jsCallbackType = "JsCallback";
            var refHandlerType = "ReferenceHandler";

            var initializeMethod = typeof(RuntimeRaw).GetMethod(nameof(RuntimeRaw.InitializeInternal),
                BindingFlags.NonPublic | BindingFlags.Static);

            if (initializeMethod == null) throw new Exception("Initialize method not found");

            var initParams = initializeMethod.GetParameters();

            var callbackParam = initParams[0];
            var callbackMethod = callbackParam.ParameterType.GetMethod("Invoke");
        
            var acquireParam = initParams[1];
            var acquireMethod = acquireParam.ParameterType.GetMethod("Invoke");
        
            var releaseParam = initParams[2];
            var releaseMethod = releaseParam.ParameterType.GetMethod("Invoke");
            if (releaseMethod != acquireMethod)
                throw new Exception("CodeGen assumes that Release and Acquire have the same signature");

            WriteArrayBuilder(arrayBuilderType);

            Builder.Append("type ").Append(jsCallbackType).Append(" = (").AppendParams(callbackMethod).AppendLine(") => void;");
            Builder.Append("type ").Append(refHandlerType).Append(" = (").AppendParams(acquireMethod).AppendLine(") => boolean;");

            Builder.AppendLine();

            using (Builder.AppendLine($"interface {JsRuntimeConstructorType} ").Brace())
            {
                Builder.Append("new (")
                    .Append("arrayBuilder").Append(": ").Append(arrayBuilderType).Append(", ")
                    .Append(callbackParam.Name).Append(": ").Append(jsCallbackType).Append(", ")
                    .Append(acquireParam.Name).Append(": ").Append(refHandlerType).Append(", ")
                    .Append(releaseParam.Name).Append(": ").Append(refHandlerType).Append(")")
                    .AppendLine($": {JsRuntimeType};");
            }

        }

    }
}
